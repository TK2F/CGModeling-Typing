<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CGモデリング タイピングゲーム NEO</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Meiryo', 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            touch-action: manipulation;
            -webkit-touch-callout: none;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.7.0/lib/p5.js"></script>
    <script>
const sketch = (p) => {
    // Game constants
    const GAME_DURATIONS = { tutorial: 120, easy: 90, normal: 60, hard: 45 };
    const WORD_FALL_SPEEDS = { tutorial: 0.4, easy: 0.7, normal: 1.0, hard: 1.5 };
    const SPAWN_INTERVALS = { tutorial: 3500, easy: 2500, normal: 2000, hard: 1500 };
    const GAME_VERSION = 'v3.0.0 Final Mix'; // Updated version

    const GAME_STATES = {
        MENU: 'menu', SETTINGS: 'settings', HIGHSCORES: 'highscores',
        TUTORIAL: 'tutorial', PLAYING: 'playing', PAUSED: 'paused', RESULTS: 'results'
    };

    // Game variables
    let width, height;
    let currentInput = '';
    let words = [];
    let particles = [];
    let soundEnabled = true;
    let bgmPlaying = false;
    let gameTimerInterval = null;
    let isGamePausedManually = false;

    // Helper: Katakana to Hiragana
    function katakanaToHiragana(str) {
        return str.replace(/[\u30a1-\u30f6]/g, function(match) {
            var chr = match.charCodeAt(0) - 0x60;
            return String.fromCharCode(chr);
        });
    }

    const kanaToRomaji = {
        // Hiragana
        'あ': 'a', 'い': 'i', 'う': 'u', 'え': 'e', 'お': 'o',
        'か': 'ka', 'き': 'ki', 'く': 'ku', 'け': 'ke', 'こ': 'ko',
        'さ': 'sa', 'し': 'shi', 'す': 'su', 'せ': 'se', 'そ': 'so',
        'た': 'ta', 'ち': 'chi', 'つ': 'tsu', 'て': 'te', 'と': 'to',
        'な': 'na', 'に': 'ni', 'ぬ': 'nu', 'ね': 'ne', 'の': 'no',
        'は': 'ha', 'ひ': 'hi', 'ふ': 'fu', 'へ': 'he', 'ほ': 'ho',
        'ま': 'ma', 'み': 'mi', 'む': 'mu', 'め': 'me', 'も': 'mo',
        'や': 'ya', 'ゆ': 'yu', 'よ': 'yo',
        'ら': 'ra', 'り': 'ri', 'る': 'ru', 'れ': 're', 'ろ': 'ro',
        'わ': 'wa', 'を': 'wo', 'ん': 'n',
        'が': 'ga', 'ぎ': 'gi', 'ぐ': 'gu', 'げ': 'ge', 'ご': 'go',
        'ざ': 'za', 'じ': 'ji', 'ず': 'zu', 'ぜ': 'ze', 'ぞ': 'zo',
        'だ': 'da', 'ぢ': 'ji', 'づ': 'zu', 'で': 'de', 'ど': 'do',
        'ば': 'ba', 'び': 'bi', 'ぶ': 'bu', 'べ': 'be', 'ぼ': 'bo',
        'ぱ': 'pa', 'ぴ': 'pi', 'ぷ': 'pu', 'ぺ': 'pe', 'ぽ': 'po',
        'きゃ': 'kya', 'きゅ': 'kyu', 'きょ': 'kyo',
        'しゃ': 'sha', 'しゅ': 'shu', 'しょ': 'sho',
        'ちゃ': 'cha', 'ちゅ': 'chu', 'ちょ': 'cho',
        'にゃ': 'nya', 'にゅ': 'nyu', 'にょ': 'nyo',
        'ひゃ': 'hya', 'ひゅ': 'hyu', 'ひょ': 'hyo',
        'みゃ': 'mya', 'みゅ': 'myu', 'みょ': 'myo',
        'りゃ': 'rya', 'りゅ': 'ryu', 'りょ': 'ryo',
        'ぎゃ': 'gya', 'ぎゅ': 'gyu', 'ぎょ': 'gyo',
        'じゃ': 'ja', 'じゅ': 'ju', 'じょ': 'jo',
        'びゃ': 'bya', 'びゅ': 'byu', 'びょ': 'byo',
        'ぴゃ': 'pya', 'ぴゅ': 'pyu', 'ぴょ': 'pyo',
        'うぃ': 'wi', 'うぇ': 'we', 'うぉ': 'wo', // Note: 'wo' is also 'を'
        'ふぁ': 'fa', 'ふぃ': 'fi', 'ふぇ': 'fe', 'ふぉ': 'fo',
        'つぁ': 'tsa', 'つぃ': 'tsi', 'つぇ': 'tse', 'つぉ': 'tso',
        'ちぇ': 'che', 'しぇ': 'she', 'じぇ': 'je',
        'っ': 'xtsu', // Small tsu - placeholder, actual handling is context-dependent (doubles next consonant)
        'ぁ': 'xa', 'ぃ': 'xi', 'ぅ': 'xu', 'ぇ': 'xe', 'ぉ': 'xo', // Small vowels
        'ゃ': 'xya', 'ゅ': 'xyu', 'ょ': 'xyo',
        // Katakana
        'ア': 'a', 'イ': 'i', 'ウ': 'u', 'エ': 'e', 'オ': 'o',
        'カ': 'ka', 'キ': 'ki', 'ク': 'ku', 'ケ': 'ke', 'コ': 'ko',
        'サ': 'sa', 'シ': 'shi', 'ス': 'su', 'セ': 'se', 'ソ': 'so',
        'タ': 'ta', 'チ': 'chi', 'ツ': 'tsu', 'テ': 'te', 'ト': 'to',
        'ナ': 'na', 'ニ': 'ni', 'ヌ': 'nu', 'ネ': 'ne', 'ノ': 'no',
        'ハ': 'ha', 'ヒ': 'hi', 'フ': 'fu', 'ヘ': 'he', 'ホ': 'ho',
        'マ': 'ma', 'ミ': 'mi', 'ム': 'mu', 'メ': 'me', 'モ': 'mo',
        'ヤ': 'ya', 'ユ': 'yu', 'ヨ': 'yo',
        'ラ': 'ra', 'リ': 'ri', 'ル': 'ru', 'レ': 're', 'ロ': 'ro',
        'ワ': 'wa', 'ヲ': 'wo', 'ン': 'n',
        'ガ': 'ga', 'ギ': 'gi', 'グ': 'gu', 'ゲ': 'ge', 'ゴ': 'go',
        'ザ': 'za', 'ジ': 'ji', 'ズ': 'zu', 'ゼ': 'ze', 'ゾ': 'zo',
        'ダ': 'da', 'ヂ': 'ji', 'ヅ': 'zu', 'デ': 'de', 'ド': 'do',
        'バ': 'ba', 'ビ': 'bi', 'ブ': 'bu', 'ベ': 'be', 'ボ': 'bo',
        'パ': 'pa', 'ピ': 'pi', 'プ': 'pu', 'ペ': 'pe', 'ポ': 'po',
        'キャ': 'kya', 'キュ': 'kyu', 'キョ': 'kyo',
        'シャ': 'sha', 'シュ': 'shu', 'ショ': 'sho',
        'チャ': 'cha', 'チュ': 'chu', 'チョ': 'cho',
        'ニャ': 'nya', 'ニュ': 'nyu', 'ニョ': 'nyo',
        'ヒャ': 'hya', 'ヒュ': 'hyu', 'ヒョ': 'hyo',
        'ミャ': 'mya', 'ミュ': 'myu', 'ミョ': 'myo',
        'リャ': 'rya', 'リュ': 'ryu', 'リョ': 'ryo',
        'ギャ': 'gya', 'ギュ': 'gyu', 'ギョ': 'gyo',
        'ジャ': 'ja', 'ジュ': 'ju', 'ジョ': 'jo',
        'ビャ': 'bya', 'ビュ': 'byu', 'ビョ': 'byo',
        'ピャ': 'pya', 'ピュ': 'pyu', 'ピョ': 'pyo',
        'ウィ': 'wi', 'ウェ': 'we', 'ウォ': 'wo',
        'ファ': 'fa', 'フィ': 'fi', 'フェ': 'fe', 'フォ': 'fo',
        'ツァ': 'tsa', 'ツィ': 'tsi', 'ツェ': 'tse', 'ツォ': 'tso',
        'チェ': 'che', 'シェ': 'she', 'ジェ': 'je',
        'ッ': 'xtsu',
        'ァ': 'xa', 'ィ': 'xi', 'ゥ': 'xu', 'ェ': 'xe', 'ォ': 'xo',
        'ャ': 'xya', 'ュ': 'xyu', 'ョ': 'xyo',
        // Special symbols from flick keyboard
        '゛': '_DAKUTEN_', '゜': '_HANDAKUTEN_',
        // Small kana not covered by 'x' prefix that might come from "小" key
        'ゎ': 'xwa', // Small wa (rare)
        // ー (長音符 - long vowel mark)
        'ー': '-',
    };

    function convertKanaToRomaji(kana) {
        if (kanaToRomaji[kana]) {
            return kanaToRomaji[kana];
        }
        // Basic fallback for unknown kana, though the map should be comprehensive
        console.warn("Unknown Kana for Romaji conversion:", kana);
        return kana;
    }

    // VRoid Studio related words (Katakana) - from typing2.html
    const vroidWords = [
        { japanese: 'ブイロイド', romaji: 'buiroido' }, { japanese: 'スタジオ', romaji: 'sutajio' },
        { japanese: 'アバター', romaji: 'abataa' }, { japanese: 'モデリング', romaji: 'moderingu' },
        { japanese: 'テクスチャ', romaji: 'tekusuchaa' }, { japanese: 'ボーン', romaji: 'boon' },
        { japanese: 'リギング', romaji: 'rigingu' }, { japanese: 'アニメーション', romaji: 'animeeshon' },
        { japanese: 'エクスポート', romaji: 'ekusupooto' }, { japanese: 'インポート', romaji: 'inpooto' },
        { japanese: 'マテリアル', romaji: 'materiaru' }, { japanese: 'メッシュ', romaji: 'messhu' },
        { japanese: 'スキニング', romaji: 'sukiningu' }, { japanese: 'ウェイト', romaji: 'weito' },
        { japanese: 'バーテックス', romaji: 'baatekkusu' }, { japanese: 'ポリゴン', romaji: 'porigon' },
        { japanese: 'シェーダー', romaji: 'sheedaa' }, { japanese: 'ライティング', romaji: 'raitingu' },
        { japanese: 'レンダリング', romaji: 'rendaringu' }, { japanese: 'かみのけ', romaji: 'kaminoke' },
        { japanese: 'ひふ', romaji: 'hifu' }, { japanese: 'ふく', romaji: 'fuku' },
        { japanese: 'めだま', romaji: 'medama' }, { japanese: 'かお', romaji: 'kao' },
        { japanese: 'からだ', romaji: 'karada' }, { japanese: 'うで', romaji: 'ude' },
        { japanese: 'あし', romaji: 'ashi' }, { japanese: 'てのひら', romaji: 'tenohira' },
        { japanese: 'ゆび', romaji: 'yubi' }, { japanese: 'つめ', romaji: 'tsume' },
        { japanese: 'ポーズ', romaji: 'poozu' }, { japanese: 'まゆげ', romaji: 'mayuge' }
    ];

    // CG Modeling Words (Katakana) - Full list from typing.html
    const cgModelingWordsKatakana = [
        { japanese: 'ユーブイ', romaji: 'yuubui' }, { japanese: 'ノーマルマップ', romaji: 'noomarumappu' },
        { japanese: 'アンビエントオクルージョン', romaji: 'anbientookuruujon' }, { japanese: 'サブディビジョン', romaji: 'sabudibijon' },
        { japanese: 'トランスフォーム', romaji: 'toransufoomu' }, { japanese: 'アーマチュア', romaji: 'aamachua' },
        { japanese: 'キーフレーム', romaji: 'kiifureemu' }, { japanese: 'スカルプト', romaji: 'sukarupito' },
        { japanese: 'ダイナミックトポロジー', romaji: 'dainamikkutoporojii' }, { japanese: 'ローポリ', romaji: 'roopori' },
        { japanese: 'ハイポリ', romaji: 'haipori' }, { japanese: 'ピービーアール', romaji: 'piibiiaaru' },
        { japanese: 'ブループリント', romaji: 'buruupurinto' }, { japanese: 'ノード', romaji: 'noodo' },
        { japanese: 'エミッシブ', romaji: 'emisshibu' }, { japanese: 'ラフネス', romaji: 'rafunesu' },
        { japanese: 'メタリック', romaji: 'metarikku' }, { japanese: 'コリジョン', romaji: 'korijon' },
        { japanese: 'パーティクル', romaji: 'paatikuru' }, { japanese: 'プロシージャル', romaji: 'puroshijaru' },
        { japanese: 'ベクター', romaji: 'bekutaa' }, { japanese: 'クォータニオン', romaji: 'kuootanion' },
        { japanese: 'シェイプキー', romaji: 'sheipukii' }, { japanese: 'コンポジット', romaji: 'konpojitto' },
        { japanese: 'デバッグ', romaji: 'debaggu' }, { japanese: 'ビルド', romaji: 'birudo' },
        { japanese: 'アセット', romaji: 'asetto' }, { japanese: 'ワイヤーフレーム', romaji: 'waiaafureemu' },
        { japanese: 'シーン', romaji: 'shiin' }, { japanese: 'オブジェクト', romaji: 'obujekuto' },
        { japanese: 'モディファイア', romaji: 'modifuaia' }, { japanese: 'ピクセル', romaji: 'pikuseru' },
        { japanese: 'ブーリアン', romaji: 'buurian' }, { japanese: 'カーソル', romaji: 'kaasoru' },
        { japanese: 'グリッド', romaji: 'guriddo' }, { japanese: 'イージング', romaji: 'iijingu' },
        { japanese: 'カーブ', romaji: 'kaabu' }, { japanese: 'デプス', romaji: 'depusu' },
        { japanese: 'アルファ', romaji: 'arufa' }, { japanese: 'ブラー', romaji: 'buraa' },
        { japanese: 'カリング', romaji: 'karingu' }, { japanese: 'デカール', romaji: 'dekaaru' },
        { japanese: 'エフェクト', romaji: 'efekuto' }, { japanese: 'フィルタ', romaji: 'firuta' },
        { japanese: 'ギズモ', romaji: 'gizumo' }, { japanese: 'ハイトマップ', romaji: 'haitomappu' },
        { japanese: 'イラディアンス', romaji: 'iradeiansu' }, { japanese: 'レイヤー', romaji: 'reiyaa' },
        { japanese: 'マッピング', romaji: 'mappingu' }, { japanese: 'ミップマップ', romaji: 'mippumappu' },
        { japanese: 'オクルージョン', romaji: 'okuruujon' }, { japanese: 'パースペクティブ', romaji: 'paasupekutibu' },
        { japanese: 'プリミティブ', romaji: 'purimitibu' }, { japanese: 'リフレクション', romaji: 'rifurekushon' },
        { japanese: 'スケール', romaji: 'sukeeru' }, { japanese: 'タイル', romaji: 'tairu' },
        { japanese: 'ビューポート', romaji: 'byuupooto' },
        { japanese: 'アセットパイプライン', romaji: 'asettopaipurain' },
        { japanese: 'インスタンス', romaji: 'insutansu' },
        { japanese: 'エクストルード', romaji: 'ekusutoruudo' },
        { japanese: 'オクルージョンカリング', romaji: 'okuruujonkaringu' },
        { japanese: 'カプセル', romaji: 'kapuseru' },
        { japanese: 'キネマティクス', romaji: 'kinematikusu' },
        { japanese: 'グローバルイルミネーション', romaji: 'guroobaruirumineeshon' },
        { japanese: 'コンストレイント', romaji: 'konsutoreinto' },
        { japanese: 'サーフェスモデリング', romaji: 'saafesumoderingu' },
        { japanese: 'ジオメトリ', romaji: 'jiometori' },
        { japanese: 'シンメトリ', romaji: 'shinmetori' },
        { japanese: 'スイープ', romaji: 'suiipu' },
        { japanese: 'スプライン', romaji: 'supurain' },
        { japanese: 'セルシェーディング', romaji: 'serushieedingu' },
        { japanese: 'テッセレーション', romaji: 'tessereeshon' },
        { japanese: 'デフォーメーション', romaji: 'defoomeeshon' },
        { japanese: 'トゥーンシェーディング', romaji: 'tuunshieedingu' },
        { japanese: 'ドープシート', romaji: 'doopushiito' },
        { japanese: 'ナーバス', romaji: 'naabasu' },
        { japanese: 'ノンリニアアニメーション', romaji: 'nonriniaanimeeshon' },
        { japanese: 'ハードサーフェス', romaji: 'haadosaafesu' },
        { japanese: 'ハイトフィールド', romaji: 'haitofiirudo' },
        { japanese: 'バンプマッピング', romaji: 'banpumappingu' },
        { japanese: 'ピボットポイント', romaji: 'pibottopointo' },
        { japanese: 'フィレット', romaji: 'firetto' },
        { japanese: 'フォトンマッピング', romaji: 'fotonmappingu' },
        { japanese: 'ベイク', romaji: 'beiku' },
        { japanese: 'ベジェカーブ', romaji: 'bejiekaabu' },
        { japanese: 'ヘアーシステム', romaji: 'heaashisutemu' },
        { japanese: 'ボリュームレンダリング', romaji: 'boryuumurendaringu' },
        { japanese: 'マーカー', romaji: 'maakaa' },
        { japanese: 'マッスルスシステム', romaji: 'massurusushisutemu' },
        { japanese: 'ミップマッピング', romaji: 'mippumappingu' },
        { japanese: 'モーフィング', romaji: 'moofingu' },
        { japanese: 'モーションパス', romaji: 'mooshonpasu' },
        { japanese: 'ラティス', romaji: 'ratisu' },
        { japanese: 'リトポロジー', romaji: 'ritoporojii' },
        { japanese: 'レベルオブディテール', romaji: 'reberuobuditeeru' },
        { japanese: 'レイディオシティ', romaji: 'reidioshiti' },
        { japanese: 'ロフト', romaji: 'rofuto' },
        { japanese: 'ウェイトペイント', romaji: 'weitopeinto' },
        { japanese: 'クロスシミュレーション', romaji: 'kuroshushimyureeshon' },
        { japanese: 'デジタルクレイ', romaji: 'dejitarukurei' },
        { japanese: 'フローマップ', romaji: 'furoomappu' },
        { japanese: 'プロップ', romaji: 'puroppu' },
        { japanese: 'メッシュスムージング', romaji: 'messhusumuujingu' },
        { japanese: 'リバースキネマティクス', romaji: 'ribaasukinematikusu' },
        { japanese: 'サブサーフェススキャタリング', romaji: 'sabusāfesusukyattaringu' },
        { japanese: 'アンラップ', romaji: 'anrappu' },
        { japanese: '頂点法線', romaji: 'choutenhoosen' }
    ];

    // Initialize Hiragana word lists dynamically
    const vroidWordsHiragana = [];
    const cgModelingWordsHiragana = [];

    vroidWords.forEach(w => vroidWordsHiragana.push({ japanese: katakanaToHiragana(w.japanese), romaji: w.romaji }));
    cgModelingWordsKatakana.forEach(w => cgModelingWordsHiragana.push({ japanese: katakanaToHiragana(w.japanese), romaji: w.romaji }));

    let allKatakanaWords = [];
    let allHiraganaWords = [];

    let gameState = GAME_STATES.MENU;
    let score = 0;
    let timeLeft = GAME_DURATIONS.normal;
    let lastSpawnTime = 0;
    let difficulty = 'normal';
    let wordMode = 'katakana';
    let combo = 0;
    let maxCombo = 0;
    let virtualKeyboard = [];
    let tutorialStep = 0;
    let isVirtualKeyboardVisible = false;
    let isMobile = false;
    let gameStats = { wordsTyped: 0, totalKeystrokes: 0, correctKeystrokes: 0, totalCharsTyped: 0, correctCharsTyped: 0 };

    // Flick input variables
    let flickKeyboardLayout = [];
    let isFlickInputActive = false;
    let touchState = { startX: 0, startY: 0, currentKey: null, isFlicking: false, lastTapTime: 0, doubleTapDelay: 300 };

    let sounds = {
        type: null, correct: null, word_complete: null, wrong: null,
        combo_increase: null, combo_break: null, click: null, bgm: null
    };
    let highScores = { easy: 0, normal: 0, hard: 0 };

    // Visual Keyboard Overlay
    let keyboardOverlay = {
        layout: [
            ['q','w','e','r','t','y','u','i','o','p'],
            ['a','s','d','f','g','h','j','k','l'],
            ['z','x','c','v','b','n','m']
        ],
        keyStates: {}, // To store highlight time for each key
        keyWidth: 0, keyHeight: 0, startX: 0, startY: 0, padding: 2,
        highlightDuration: 20 // frames
    };

    // Screen Shake Effect
    let screenShakeTime = 0;
    let screenShakeMagnitude = 0;

    function triggerScreenShake(duration = 10, magnitude = 3) {
        screenShakeTime = duration;
        screenShakeMagnitude = magnitude;
    }

    class Button {
        constructor(x, y, w, h, text, action, icon = null) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.text = text; this.action = action; this.icon = icon;
        }
        isClicked(px, py) {
            return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;
        }
        draw(isSelected = false, customColor = null) {
            let buttonColor = customColor ? customColor : (isSelected ? p.color(255, 220, 100, 240) : p.color(255, 255, 255, 220));
            p.fill(buttonColor);
            p.stroke(100); p.strokeWeight(2);
            p.rect(this.x, this.y, this.w, this.h, 10);
            p.fill(50); p.textAlign(p.CENTER, p.CENTER);
            let baseTextSize = Math.min(this.h * 0.38, 22); // Slightly reduced for regular text
            if (this.icon) baseTextSize = Math.min(this.h * 0.45, 28); // Slightly reduced for icon
            p.textSize(baseTextSize);
            p.text(this.icon ? this.icon : this.text, this.x + this.w / 2, this.y + this.h / 2);
        }
    }

    class ToggleButton extends Button {
        constructor(x, y, w, h, textOn, textOff, isOn, action) {
            super(x, y, w, h, isOn ? textOn : textOff, action);
            this.textOn = textOn; this.textOff = textOff; this.isOn = isOn;
        }
        toggle() {
            this.isOn = !this.isOn;
            this.text = this.isOn ? this.textOn : this.textOff;
            if (typeof this.action === 'function') this.action.call(this);
        }
        draw() {
            let buttonColor = this.isOn ? p.color(100, 255, 100, 220) : p.color(255, 100, 100, 220);
            super.draw(false, buttonColor);
        }
    }

    class Word {
        constructor(wordData) {
            this.japanese = wordData.japanese; this.romaji = wordData.romaji;
            this.x = p.random(p.textWidth(this.japanese) + 50, width - (p.textWidth(this.japanese) + 50));
            this.y = -50;
            this.baseSpeed = WORD_FALL_SPEEDS[difficulty];
            this.speedRandomComponent = p.random(-0.1, 0.15);
            this.typedLength = 0; this.missTyped = false; this.highlightTime = 0;
            this.isActive = true; this.isCleared = false; this.alpha = 255;
        }

        update() {
            if (!this.isActive) return;

            if (this.isCleared) { // Word cleared, animate out
                this.alpha -= 25; // Fade out
                this.y -= 2;      // Move up slightly
                if (this.alpha <= 0) this.isActive = false;
                return;
            }

            let currentSpeed = this.baseSpeed * (difficulty === 'hard' ? 1.2 : 1) + this.speedRandomComponent;
            this.y += currentSpeed;

            if (this.highlightTime > 0) this.highlightTime--;
            if (this.y > height + 50) {
                 this.isActive = false;
                 if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL) {
                    if (combo > 0) playSound(sounds.combo_break);
                    combo = 0;
                 }
            }
        }

        draw() {
            if (!this.isActive) return;
            let currentAlpha = this.isCleared ? this.alpha : (this.missTyped ? 200 : 240); // Increased opacity
            let bgColor = this.highlightTime > 0 ? p.color(255, 255, 150, currentAlpha) : p.color(255, 255, 255, currentAlpha);
            p.fill(bgColor);
            p.stroke(100, currentAlpha); p.strokeWeight(2);
            // Adjust rectWidth calculation if text sizes change significantly, for now it should be okay.
            const rectWidth = Math.max(160, p.textWidth(this.japanese) + 50, p.textWidth(this.romaji) + 50); // Slightly increased base width
            p.rect(this.x - 10, this.y - 28, rectWidth, 56, 10); // Slightly increased height and adjusted y

            p.fill(50, this.alpha); p.textAlign(p.LEFT);
            p.textSize(18); p.text(this.japanese, this.x, this.y - 7); // Adjusted y for new text size & rect

            p.textSize(16); // Increased Romaji text size
            if (this.typedLength > 0) {
                p.fill(0, 150, 0, this.alpha);
                p.text(this.romaji.substring(0, this.typedLength), this.x, this.y + 15);
            }
            p.fill(this.missTyped ? p.color(200,0,0, this.alpha) : p.color(50, this.alpha));
            let typedWidth = p.textWidth(this.romaji.substring(0, this.typedLength));
            p.text(this.romaji.substring(this.typedLength), this.x + typedWidth, this.y + 17); // Adjusted y for new text size & rect
        }

        isFullyTypedBy(input) { return !this.isCleared && this.romaji === input; }

        updateStateFromInput(input) {
            if (this.isCleared) return;
            if (this.romaji.startsWith(input)) {
                this.missTyped = false; this.highlightTime = 5; this.typedLength = input.length;
            } else {
                let i = 0;
                while (i < input.length && i < this.romaji.length && input[i] === this.romaji[i]) i++;
                this.typedLength = i;
                this.missTyped = input.length > i;
                this.highlightTime = 0;
            }
        }
        
        markCleared() {
            this.isCleared = true;
        }
    }

    class Particle {
        constructor(x, y, pColor) {
            this.x = x; this.y = y;
            this.vx = p.random(-4, 4); this.vy = p.random(-5, 1);
            this.life = p.random(20, 40); this.maxLife = this.life;
            this.size = p.random(5, 12);
            this.color = pColor || p.color(p.random(200,255), p.random(180,220), p.random(0,100)); // Gold/Orange tones
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += 0.2; this.life--;
            this.vx *= 0.98; // air resistance
        }
        draw() {
            let alpha = p.map(this.life, 0, this.maxLife, 0, 255);
            p.fill(p.red(this.color), p.green(this.color), p.blue(this.color), alpha);
            p.noStroke(); p.ellipse(this.x, this.y, this.size, this.size);
        }
        isDead() { return this.life <= 0; }
    }

    const menuButtons = []; const difficultySettingButtons = []; const modeSettingButtons = [];
    const settingsScreenButtons = []; const pauseMenuButtons = [];
    let gameplayPauseButton;

    function createButtons() {
        const buttonWidth = Math.min(300, width - 40);
        const buttonHeight = Math.min(60, height / 10);
        const centerX = width / 2 - buttonWidth / 2;
        const itemSpacing = buttonHeight + 10;

        menuButtons.length = 0;
        menuButtons.push(new Button(centerX, height / 2 - buttonHeight * 2.5, buttonWidth, buttonHeight, "スタート", () => { startGame(); }));
        menuButtons.push(new Button(centerX, height / 2 - buttonHeight * 1.25, buttonWidth, buttonHeight, "チュートリアル", () => { startTutorial(); }));
        menuButtons.push(new Button(centerX, height / 2, buttonWidth, buttonHeight, "設定", () => { gameState = GAME_STATES.SETTINGS; }));
        menuButtons.push(new Button(centerX, height / 2 + buttonHeight * 1.25, buttonWidth, buttonHeight, "ハイスコア", () => { gameState = GAME_STATES.HIGHSCORES; }));

        let currentY = height / 3 - buttonHeight * 1.5;
        modeSettingButtons.length = 0;
        modeSettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "カタカナモード", () => { wordMode = 'katakana'; })); currentY += itemSpacing;
        modeSettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "ひらがなモード", () => { wordMode = 'hiragana'; })); currentY += itemSpacing;
        modeSettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "ミックスモード", () => { wordMode = 'mixed'; })); currentY += itemSpacing * 1.5;

        difficultySettingButtons.length = 0;
        difficultySettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "かんたん", () => { difficulty = 'easy'; })); currentY += itemSpacing;
        difficultySettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "ふつう", () => { difficulty = 'normal'; })); currentY += itemSpacing;
        difficultySettingButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "むずかしい", () => { difficulty = 'hard'; })); currentY += itemSpacing * 1.5;

        settingsScreenButtons.length = 0;
        const soundToggle = new ToggleButton(centerX, currentY, buttonWidth, buttonHeight, "サウンド: オン", "サウンド: オフ", soundEnabled,
            function() {
                soundEnabled = this.isOn;
                if (sounds.bgm) {
                    if (soundEnabled && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL) && !bgmPlaying) playBackgroundMusic();
                    else if (!soundEnabled && bgmPlaying) { sounds.bgm.pause(); bgmPlaying = false; }
                }
            }
        );
        settingsScreenButtons.push(soundToggle); currentY += itemSpacing;

        if (isMobile) {
            const flickToggle = new ToggleButton(centerX, currentY, buttonWidth, buttonHeight, "入力: フリック", "入力: QWERTY", isFlickInputActive,
                function() {
                    isFlickInputActive = this.isOn;
                    if (isFlickInputActive) {
                        if (flickKeyboardLayout.length === 0) createFlickKeyboard(); // Ensure layout exists
                        isVirtualKeyboardVisible = false; // Hide QWERTY if flick is active
                    } else {
                        isVirtualKeyboardVisible = true; // Show QWERTY if flick is inactive
                    }
                }
            );
            settingsScreenButtons.push(flickToggle); currentY += itemSpacing;
        }

        settingsScreenButtons.push(new Button(centerX, currentY, buttonWidth, buttonHeight, "もどる", () => { gameState = GAME_STATES.MENU; }));

        pauseMenuButtons.length = 0;
        const pauseButtonWidth = Math.min(250, width - 60); const pauseButtonHeight = Math.min(50, height / 12);
        const pauseCenterX = width / 2 - pauseButtonWidth / 2; let pauseY = height / 2 - pauseButtonHeight * 1.5 - 10;
        pauseMenuButtons.push(new Button(pauseCenterX, pauseY, pauseButtonWidth, pauseButtonHeight, "ゲーム再開", () => { resumeGame(); })); pauseY += pauseButtonHeight + 15;
        pauseMenuButtons.push(new Button(pauseCenterX, pauseY, pauseButtonWidth, pauseButtonHeight, "リトライ", () => { retryGame(); })); pauseY += pauseButtonHeight + 15;
        pauseMenuButtons.push(new Button(pauseCenterX, pauseY, pauseButtonWidth, pauseButtonHeight, "メニューに戻る", () => { returnToMenu(); }));

        const gpButtonSize = Math.min(50, width/15, height/15);
        gameplayPauseButton = new Button(width - gpButtonSize - 15, 15, gpButtonSize, gpButtonSize, "", () => { pauseGame(); }, "||");
    }

    function createVirtualKeyboard() {
        virtualKeyboard = []; 
        const keys = [
            ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
            ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
            ['z', 'x', 'c', 'v', 'b', 'n', 'm']
        ];
        const keySize = Math.min(width / 11, 45);
        const padding = Math.max(2, keySize * 0.05);
        const totalKeyboardHeight = (keySize + padding) * 4.5; 
        const startY = height - totalKeyboardHeight;

        for (let row = 0; row < keys.length; row++) {
            const numKeysInRow = keys[row].length;
            const rowWidth = numKeysInRow * keySize + (numKeysInRow - 1) * padding;
            let startX = (width - rowWidth) / 2;
            for (let col = 0; col < numKeysInRow; col++) {
                virtualKeyboard.push({
                    key: keys[row][col], x: startX + col * (keySize + padding),
                    y: startY + row * (keySize + padding), width: keySize, height: keySize,
                    label: keys[row][col].toUpperCase()
                });
            }
        }
        const specialKeyHeight = keySize; const backspaceWidth = keySize * 1.8;
        const clearKeyWidth = width * 0.6; const spacebarY = startY + keys.length * (keySize + padding) + padding;
        
        let lastKeyInThirdRow = virtualKeyboard[virtualKeyboard.length-1]; // 'm' key
        let lastKeyInSecondRow = virtualKeyboard[virtualKeyboard.length-1 - (keys[2].length)]; // 'l' key

        virtualKeyboard.push({
            key: 'backspace', label: '←',
            x: lastKeyInThirdRow.x + keySize + padding, 
            y: lastKeyInThirdRow.y,
            width: backspaceWidth, height: specialKeyHeight
        });

        // Add 'フリック' (Flick) toggle key to QWERTY
        const flickToggleKeyWidth = keySize * 2;
        virtualKeyboard.push({
            key: 'toggle_flick', label: 'フリック',
            x: (width - clearKeyWidth) / 2 - flickToggleKeyWidth - padding, // Position left of clear key
            y: spacebarY,
            width: flickToggleKeyWidth, height: specialKeyHeight
        });

        virtualKeyboard.push({
            key: 'clear', label: '消去',
            x: (width - clearKeyWidth) / 2 , // Original X for clear key
            y: spacebarY,
            width: clearKeyWidth - flickToggleKeyWidth - padding, // Adjust width of clear key
            height: specialKeyHeight
        });
    }

    function initKeyboardOverlay() {
        keyboardOverlay.keyWidth = Math.max(25, width / 25);
        keyboardOverlay.keyHeight = keyboardOverlay.keyWidth;
        keyboardOverlay.padding = Math.max(2, keyboardOverlay.keyWidth * 0.1);
        const firstRowWidth = keyboardOverlay.layout[0].length * (keyboardOverlay.keyWidth + keyboardOverlay.padding) - keyboardOverlay.padding;
        keyboardOverlay.startX = (width - firstRowWidth) / 2;
        keyboardOverlay.startY = height - (keyboardOverlay.layout.length * (keyboardOverlay.keyHeight + keyboardOverlay.padding) + keyboardOverlay.keyHeight * 0.5); // Position higher
    }

    function createFlickKeyboard() {
        flickKeyboardLayout = [];
        const keyRows = 4;
        const mainKeyCols = 3;
        const utilityKeyCols = 1; // For ABC, backspace, clear etc.

        const availableHeight = height * 0.4; // Max 40% of screen for keyboard
        const yPadding = 10;
        let keyHeight = (availableHeight - (keyRows - 1) * yPadding) / keyRows;

        const availableWidth = width;
        const xPadding = 5;
        let keyWidth = (availableWidth - (mainKeyCols + utilityKeyCols -1) * xPadding ) / (mainKeyCols + utilityKeyCols);

        // Make keys squarish, but prioritize height calculation for screen fit.
        keyHeight = Math.min(keyHeight, keyWidth * 1.2); // Ensure keys are not too tall
        keyWidth = Math.min(keyWidth, keyHeight * 1.2); // Ensure keys are not too wide

        const totalKeyboardActualWidth = (mainKeyCols * keyWidth) + ((mainKeyCols -1) * xPadding) + keyWidth + xPadding; // Main 3 cols + 1 utility col
        const startX = (width - totalKeyboardActualWidth) / 2;
        const totalFlickKeyboardHeight = (keyRows * keyHeight) + ((keyRows - 1) * yPadding);
        const startY = height - totalFlickKeyboardHeight - 10; // 10px padding from bottom

        const keysDef = [
            { label: 'あ', id: 'a_row', flicks: { center: 'あ', left: 'い', up: 'う', right: 'え', down: 'お' } },
            { label: 'か', id: 'ka_row', flicks: { center: 'か', left: 'き', up: 'く', right: 'け', down: 'こ' } },
            { label: 'さ', id: 'sa_row', flicks: { center: 'さ', left: 'し', up: 'す', right: 'せ', down: 'そ' } },
            { label: 'た', id: 'ta_row', flicks: { center: 'た', left: 'ち', up: 'つ', right: 'て', down: 'と' } },
            { label: 'な', id: 'na_row', flicks: { center: 'な', left: 'に', up: 'ぬ', right: 'ね', down: 'の' } },
            { label: 'は', id: 'ha_row', flicks: { center: 'は', left: 'ひ', up: 'ふ', right: 'へ', down: 'ほ' } },
            { label: 'ま', id: 'ma_row', flicks: { center: 'ま', left: 'み', up: 'む', right: 'め', down: 'も' } },
            { label: 'や', id: 'ya_row', flicks: { center: 'や', left: 'ゃ', up: 'ゆ', right: 'ゅ', down: 'よ', centerAlt: 'ょ'} }, // Added smalls
            { label: 'ら', id: 'ra_row', flicks: { center: 'ら', left: 'り', up: 'る', right: 'れ', down: 'ろ' } },
            { label: 'わ', id: 'wa_row', flicks: { center: 'わ', left: 'を', up: 'ん', down: 'ー' } }, // Added long vowel mark
            { label: '小', id: 'small_kana', flicks: { center: 'っ', left: 'ゃ', up: 'ゅ', right: 'ょ', down: 'ぇ'} },
            { label: '゛゜', id: 'dakuten_handakuten', flicks: { center: '゛', up: '゜'} }
        ];

        let currentX = startX;
        let currentY = startY;
        let keysInRow = 0;

        for (let i = 0; i < keysDef.length; i++) {
            flickKeyboardLayout.push({
                ...keysDef[i],
                x: currentX, y: currentY, w: keyWidth, h: keyHeight
            });
            keysInRow++;
            currentX += keyWidth + padding;
            if (keysInRow >= numCols) {
                keysInRow = 0;
                currentX = startX;
                currentY += keyHeight + padding;
            }
        }

        // Add utility keys (Backspace, Clear) in a separate column or row
        currentY = startY; // Reset Y for utility column (example)
        currentX = startX + (numCols * (keyWidth + padding)); // Position to the right of main keys

        flickKeyboardLayout.push({ label: '←', id: 'backspace', x: currentX, y: currentY, w: keyWidth, h: keyHeight, flicks: { center: 'backspace' } });
        currentY += keyHeight + padding;
        flickKeyboardLayout.push({ label: '消去', id: 'clear', x: currentX, y: currentY, w: keyWidth, h: keyHeight, flicks: { center: 'clear' } });
        currentY += keyHeight + padding;
        // Example: Add a dedicated small tsu key if needed, though "小" covers it.
        // flickKeyboardLayout.push({ label: 'っ', id: 'small_tsu', x: currentX, y: currentY, w: keyWidth, h: keyHeight, flicks: { center: 'っ'} });
        // currentY += keyHeight + padding;
        flickKeyboardLayout.push({ label: 'ABC', id: 'toggle_qwerty', x: currentX, y: currentY, w: keyWidth, h: keyHeight, flicks: { center: 'toggle_qwerty' } });


    }

    function drawFlickKeyboard() {
        // flickKeyboardLayout.push({ label: 'あ', x: currentX, y: currentY, w: keyWidth, h: keyHeight, flicks: { center: 'あ' } });
    }

    function drawFlickKeyboard() {
        if (flickKeyboardLayout.length === 0 && isMobile && isFlickInputActive) { // Ensure layout is created if needed
            createFlickKeyboard();
        }
        if (flickKeyboardLayout.length === 0) return;


        for (const key of flickKeyboardLayout) {
            p.fill(230, 230, 230, 220);
            p.stroke(150);
            p.strokeWeight(1);
            p.rect(key.x, key.y, key.w, key.h, 8);
            p.fill(30);
            p.textAlign(p.CENTER, p.CENTER);
            p.textSize(Math.min(key.w, key.h) * 0.35); // Adjusted for potentially smaller keys / more text
            p.text(key.label, key.x + key.w / 2, key.y + key.h / 2);

            if (touchState.isFlicking && touchState.currentKey === key) {
                p.fill(0, 0, 0, 100); // Dark overlay on main key
                p.rect(key.x, key.y, key.w, key.h, 8);

                // Draw flick hints
                p.textSize(Math.min(key.w, key.h) * 0.3);
                const flickHintOffsetX = key.w * 0.7;
                const flickHintOffsetY = key.h * 0.7;

                if (key.flicks.up) {
                    p.fill(50, 100, 200, 200); p.ellipse(key.x + key.w / 2, key.y - flickHintOffsetY, key.w*0.6, key.h*0.6);
                    p.fill(255); p.text(key.flicks.up, key.x + key.w / 2, key.y - flickHintOffsetY);
                }
                if (key.flicks.down) {
                     p.fill(50, 100, 200, 200); p.ellipse(key.x + key.w / 2, key.y + key.h + flickHintOffsetY, key.w*0.6, key.h*0.6);
                    p.fill(255); p.text(key.flicks.down, key.x + key.w / 2, key.y + key.h + flickHintOffsetY);
                }
                if (key.flicks.left) {
                     p.fill(50, 100, 200, 200); p.ellipse(key.x - flickHintOffsetX, key.y + key.h / 2, key.w*0.6, key.h*0.6);
                    p.fill(255); p.text(key.flicks.left, key.x - flickHintOffsetX, key.y + key.h / 2);
                }
                if (key.flicks.right) {
                     p.fill(50, 100, 200, 200); p.ellipse(key.x + key.w + flickHintOffsetX, key.y + key.h / 2, key.w*0.6, key.h*0.6);
                    p.fill(255); p.text(key.flicks.right, key.x + key.w + flickHintOffsetX, key.y + key.h / 2);
                }
            }
        }
    }
    
    function playSound(soundObj, volume = 1.0) {
        if (soundEnabled && soundObj) {
            soundObj.volume = volume;
            soundObj.currentTime = 0; 
            soundObj.play().catch(e => console.warn(`Error playing sound ${soundObj.src || 'unknown'}:`, e));
        }
    }

    function loadSound(path, defaultVolume = 1.0) {
        try {
            const audio = new Audio(path);
            audio.volume = defaultVolume;
            audio.onerror = () => {
                console.warn(`Sound not loaded or error: ${path}. Game will run without this sound.`);
                for (let key in sounds) { 
                    if (sounds[key] && sounds[key].src && sounds[key].src.endsWith(path)) {
                        sounds[key] = null; break;
                    }
                }
            };
            return audio;
        } catch (e) {
            console.warn(`Could not attempt to load sound ${path}: ${e}`);
            return null;
        }
    }

    function loadSounds() {
        sounds.type = loadSound('sounds/type.mp3', 0.7);
        sounds.correct = loadSound('sounds/correct.mp3', 0.6);
        sounds.word_complete = loadSound('sounds/word_complete.mp3', 0.8);
        sounds.wrong = loadSound('sounds/wrong.mp3', 0.7);
        sounds.combo_increase = loadSound('sounds/combo_increase.mp3', 0.8);
        sounds.combo_break = loadSound('sounds/combo_break.mp3', 0.7);
        sounds.click = loadSound('sounds/click.mp3', 0.5);
        sounds.bgm = loadSound('sounds/bgm.mp3', 0.2);
        if (sounds.bgm) sounds.bgm.loop = true;
    }

    function startGame(isRetry = false) {
        gameState = GAME_STATES.PLAYING; isGamePausedManually = false; p.loop();
        score = 0; timeLeft = GAME_DURATIONS[difficulty];
        words = []; particles = []; currentInput = '';
        lastSpawnTime = p.millis(); combo = 0; maxCombo = 0;
        gameStats = { wordsTyped: 0, totalKeystrokes: 0, correctKeystrokes: 0, totalCharsTyped: 0, correctCharsTyped: 0 };
        playSound(sounds.click);
        if (soundEnabled && sounds.bgm && !bgmPlaying) playBackgroundMusic();
        startTimer();
    }

    function startTutorial() {
        difficulty = 'tutorial'; wordMode = 'katakana'; tutorialStep = 0;
        startGame(); gameState = GAME_STATES.TUTORIAL;
    }

    function pauseGame() {
        if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL) {
            isGamePausedManually = true; gameState = GAME_STATES.PAUSED;
            if (sounds.bgm && bgmPlaying) sounds.bgm.pause();
            p.noLoop();
        }
    }
    function resumeGame() {
        if (gameState === GAME_STATES.PAUSED && isGamePausedManually) {
            isGamePausedManually = false;
            gameState = (difficulty === 'tutorial' && tutorialStep < 3) ? GAME_STATES.TUTORIAL : GAME_STATES.PLAYING;
            if (soundEnabled && sounds.bgm && !bgmPlaying) playBackgroundMusic();
            p.loop();
        }
    }
    function retryGame() {
        if (sounds.bgm && bgmPlaying) { sounds.bgm.pause(); sounds.bgm.currentTime = 0; bgmPlaying = false; }
        startGame(true);
    }
    function returnToMenu() {
        if (sounds.bgm && bgmPlaying) { sounds.bgm.pause(); bgmPlaying = false; }
        gameState = GAME_STATES.MENU; isGamePausedManually = false; p.loop(); stopTimer();
    }

    p.setup = function() {
        width = p.windowWidth; height = p.windowHeight;
        p.createCanvas(width, height); p.textFont('Meiryo, Arial');
        
        // Consolidate all words
        allKatakanaWords = [...vroidWords, ...cgModelingWordsKatakana];
        allHiraganaWords = [...vroidWordsHiragana, ...cgModelingWordsHiragana];
        
        loadSounds();
        isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        loadHighScores();
        createButtons();
        if (isMobile) {
            createVirtualKeyboard();
            createFlickKeyboard(); // Pre-calculate flick keyboard layout as well
        }
        initKeyboardOverlay(); 
    };

    function startTimer() {
        stopTimer();
        gameTimerInterval = setInterval(() => {
            if (!isGamePausedManually && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL)) {
                if (timeLeft > 0) timeLeft--;
                if (timeLeft <= 0) {
                    gameState = GAME_STATES.RESULTS;
                    if (sounds.bgm && bgmPlaying) { sounds.bgm.pause(); bgmPlaying = false; }
                    if (difficulty !== 'tutorial') checkAndSaveHighScore();
                    stopTimer(); p.noLoop();
                }
            }
        }, 1000);
    }
    function stopTimer() { if (gameTimerInterval) { clearInterval(gameTimerInterval); gameTimerInterval = null; } }
    
    function loadHighScores() {
         try {
            const savedScores = localStorage.getItem('cgTypingHighScores_NEO'); 
            if (savedScores) {
                highScores = JSON.parse(savedScores);
                if (highScores.easy == null) highScores.easy = 0; 
                if (highScores.normal == null) highScores.normal = 0;
                if (highScores.hard == null) highScores.hard = 0;
            } else highScores = { easy: 0, normal: 0, hard: 0 };
        } catch (e) { console.error("Error loading high scores:", e); highScores = { easy: 0, normal: 0, hard: 0 }; }
    }

    p.draw = function() {
        p.background(102, 126, 234); 
        for(let i = 0; i < height; i++) {
            let inter = p.map(i, 0, height, 0, 1);
            let c1 = p.color(102, 126, 234); let c2 = p.color(118, 75, 162);
            let c = p.lerpColor(c1, c2, inter); p.stroke(c); p.line(0, i, width, i);
        }
        p.noStroke();

        p.push();
        if (screenShakeTime > 0 && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL)) {
            const sx = p.random(-screenShakeMagnitude, screenShakeMagnitude);
            const sy = p.random(-screenShakeMagnitude, screenShakeMagnitude);
            p.translate(sx, sy);
            screenShakeTime--;
        }

        if (gameState === GAME_STATES.MENU) drawMenu();
        else if (gameState === GAME_STATES.SETTINGS) drawSettings();
        else if (gameState === GAME_STATES.HIGHSCORES) drawHighScores();
        else if (gameState === GAME_STATES.PLAYING) drawGameScreen();
        else if (gameState === GAME_STATES.TUTORIAL) drawTutorialScreen();
        else if (gameState === GAME_STATES.PAUSED) { p.pop(); drawPauseScreen(); } 
        else if (gameState === GAME_STATES.RESULTS) { p.pop(); drawResultsScreen(); } 
        else { p.pop(); } 
        
        if (gameState !== GAME_STATES.PAUSED && gameState !== GAME_STATES.RESULTS) {
             p.pop(); 
        }

        if (!isMobile && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL)) {
            drawKeyboardOverlay();
        }
        for (let key in keyboardOverlay.keyStates) {
            if (keyboardOverlay.keyStates[key] > 0) keyboardOverlay.keyStates[key]--;
        }
    };
    
    function drawKeyboardOverlay() {
        let currentY = keyboardOverlay.startY;
        for (let r = 0; r < keyboardOverlay.layout.length; r++) {
            let row = keyboardOverlay.layout[r];
            let rowWidth = row.length * (keyboardOverlay.keyWidth + keyboardOverlay.padding) - keyboardOverlay.padding;
            let currentX = (width - rowWidth) / 2 + (r === 1 ? keyboardOverlay.keyWidth * 0.25 : (r === 2 ? keyboardOverlay.keyWidth * 0.5 : 0)); 

            for (let keyChar of row) {
                const isHighlighted = keyboardOverlay.keyStates[keyChar] && keyboardOverlay.keyStates[keyChar] > 0;
                p.fill(isHighlighted ? p.color(0, 255, 0, 220) : p.color(50, 50, 50, 150));
                p.stroke(200, 150); p.strokeWeight(1);
                p.rect(currentX, currentY, keyboardOverlay.keyWidth, keyboardOverlay.keyHeight, 3);
                
                p.fill(255, 200); p.noStroke(); p.textAlign(p.CENTER, p.CENTER);
                p.textSize(keyboardOverlay.keyHeight * 0.5);
                p.text(keyChar.toUpperCase(), currentX + keyboardOverlay.keyWidth / 2, currentY + keyboardOverlay.keyHeight / 2);
                currentX += keyboardOverlay.keyWidth + keyboardOverlay.padding;
            }
            currentY += keyboardOverlay.keyHeight + keyboardOverlay.padding;
        }
    }

    function drawGameScreen() {
        if (p.millis() - lastSpawnTime > SPAWN_INTERVALS[difficulty]) {
            let sourceWords = [];
            if (wordMode === 'katakana') sourceWords = allKatakanaWords;
            else if (wordMode === 'hiragana') sourceWords = allHiraganaWords;
            else sourceWords = (p.random() < 0.5 ? allKatakanaWords : allHiraganaWords);
            if (sourceWords.length > 0) words.push(new Word(p.random(sourceWords)));
            lastSpawnTime = p.millis();
        }

        for (let i = words.length - 1; i >= 0; i--) {
            words[i].update(); words[i].draw();
            if (!words[i].isActive) words.splice(i, 1);
        }
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(); particles[i].draw();
            if (particles[i].isDead()) particles.splice(i, 1);
        }
        drawGamePlayUI();
        drawInputArea();
        if (isMobile) {
            if (isFlickInputActive) {
                drawFlickKeyboard();
            } else if (isVirtualKeyboardVisible) { // Only draw QWERTY if flick is not active AND it's set to visible
                drawVirtualKeyboard();
            }
        }
    }

    function drawGamePlayUI() {
        p.fill(255); p.textAlign(p.LEFT); p.textSize(24);
        p.text('Score: ' + score, 20, 40);

        if (combo > 1) {
            let comboSize = p.map(combo, 2, 50, 20, 36, true); 
            let R = p.map(combo, 2, 50, 255, 255, true); 
            let G = p.map(combo, 2, 50, 255, 100, true);
            let B = p.map(combo, 2, 50, 0, 0, true);
            p.fill(R, G, B); p.textSize(comboSize);
            p.text('Combo: ' + combo + 'x', 20, 70 + (comboSize > 20 ? (comboSize - 20)/2 : 0) ); 
        }

        p.fill(255); p.textAlign(p.RIGHT); p.textSize(24);
        p.text('Time: ' + timeLeft, width - 20 - (gameplayPauseButton ? gameplayPauseButton.w + 10 : 0), 40);
        if (gameplayPauseButton) gameplayPauseButton.draw();

        p.textAlign(p.CENTER); p.textSize(16); p.fill(255,255,255,180);
        // Standardized spacing for instruction text
        const mobileKeyboardHeight = (isMobile && isVirtualKeyboardVisible) ? (Math.min(width / 11, 45) + Math.max(2, (Math.min(width / 11, 45)) * 0.05)) * 4.5 : 0;
        const instructionTextY = isMobile ? height - mobileKeyboardHeight - 50 - 20 : keyboardOverlay.startY - 30; // 50 for input area, 20 for padding

        if (!isMobile) {
             p.text('落下する単語のローマ字を入力！', width / 2, instructionTextY);
        } else {
             // On mobile, ensure textYPos is clearly above the input area which is above the virtual keyboard (if visible)
             const inputAreaHeight = 40; // from drawInputArea
             const spaceAboveInputArea = 20; // Desired space
             let calculatedTextYPos = height - mobileKeyboardHeight - inputAreaHeight - spaceAboveInputArea - (p.textSize() / 2);
             if (mobileKeyboardHeight === 0) { // If virtual keyboard is not visible, position it relative to bottom
                calculatedTextYPos = height - inputAreaHeight - spaceAboveInputArea - 20; // Extra padding from bottom
             }
             p.text('落下する単語のローマ字を入力！', width / 2, calculatedTextYPos);
        }
    }

    function drawInputArea() {
        const inputAreaHeight = 40;
        let inputAreaY;
        const inputAreaPadding = 10;

        if (isMobile) {
            if (isFlickInputActive) {
                const keyRowsInFlick = 4; // As defined in createFlickKeyboard
                const yPaddingInFlick = 10; // As defined in createFlickKeyboard
                // Estimate flick key height (it might vary slightly based on width constraints)
                const estimatedAvailableHeight = height * 0.4;
                let flickKeyHeight = (estimatedAvailableHeight - (keyRowsInFlick - 1) * yPaddingInFlick) / keyRowsInFlick;
                flickKeyHeight = Math.min(flickKeyHeight, (width / (3+1)) * 1.2); // Approximation from createFlickKeyboard logic

                const totalFlickKeyboardH = (keyRowsInFlick * flickKeyHeight) + ((keyRowsInFlick - 1) * yPaddingInFlick);
                const flickKeyboardActualStartY = height - totalFlickKeyboardH - 10; // 10 is bottom padding
                inputAreaY = flickKeyboardActualStartY - inputAreaHeight - inputAreaPadding;
            } else if (isVirtualKeyboardVisible) { // QWERTY visible
                const qwertyKeySize = Math.min(width / 11, 45);
                const qwertyPadding = Math.max(2, qwertyKeySize * 0.05);
                const totalQwertyHeight = (qwertyKeySize + qwertyPadding) * 3 + qwertyKeySize; // 3 rows + spacebar row approximation
                inputAreaY = height - totalQwertyHeight - inputAreaHeight - inputAreaPadding - 40; // Extra 40 for better spacing
            } else { // No keyboard visible
                inputAreaY = height - inputAreaHeight - 20; // Default position near bottom
            }
        } else { // Not mobile (PC)
            inputAreaY = keyboardOverlay.startY - inputAreaHeight - inputAreaPadding;
        }
        p.fill(255, 255, 255, 200); p.stroke(100); p.strokeWeight(2);
        const inputRectWidth = 300;
        p.rect(width / 2 - inputRectWidth / 2, inputAreaY, inputRectWidth, inputAreaHeight, 10);

        p.textSize(18);
        let currentX = width / 2 - p.textWidth(currentInput) / 2; // Start drawing from a centered position
        const centerY = inputAreaY + inputAreaHeight / 2;

        let overallCorrect = true; // Assume correct until a mismatch is found for all words
        if (currentInput.length > 0) {
            let anyWordMatchesPrefix = false;
            for (const word of words) {
                if (!word.isCleared && word.romaji.startsWith(currentInput)) {
                    anyWordMatchesPrefix = true;
                    break;
                }
            }
            overallCorrect = anyWordMatchesPrefix;
        }

        for (let i = 0; i < currentInput.length; i++) {
            const char = currentInput[i];
            let charIsCorrect = false;

            if (overallCorrect) { // If the whole currentInput is a prefix of at least one word, all chars up to this point are "correct" in that context
                 charIsCorrect = true;
            } else {
                // If currentInput as a whole is not a prefix, check char by char for the first point of deviation
                // This logic is tricky because a char might be "correct" for one word's prefix but "incorrect" for another.
                // The simplest visual feedback is to color based on the `overallCorrect` status determined above.
                // A more granular per-char check against all words could be too complex or visually noisy.
                // Let's stick to: if the whole string is a valid prefix for *any* word, all typed chars are green.
                // Otherwise, the point where it deviates (or all if no prefix matches) becomes red.

                // For simplicity, if overallCorrect is false, we'll mark the character that broke the pattern as red.
                // This means we need to find the length of the longest common prefix among all words for the current input.
                let longestMatchLength = 0;
                for (const word of words) {
                    if (!word.isCleared) {
                        let matchLen = 0;
                        while(matchLen < currentInput.length && matchLen < word.romaji.length && currentInput[matchLen] === word.romaji[matchLen]) {
                            matchLen++;
                        }
                        if (matchLen > longestMatchLength) {
                            longestMatchLength = matchLen;
                        }
                    }
                }
                if (i < longestMatchLength) {
                    charIsCorrect = true;
                } else {
                    charIsCorrect = false;
                }
            }

            if (charIsCorrect) {
                p.fill(0, 150, 0); // Green for correct
            } else {
                p.fill(200, 0, 0); // Red for incorrect
            }
            p.text(char, currentX, centerY);
            currentX += p.textWidth(char);
        }
    }

    function drawVirtualKeyboard() {
        for (const key of virtualKeyboard) {
            p.fill(230, 230, 230, 220); p.stroke(150); p.strokeWeight(1);
            p.rect(key.x, key.y, key.width, key.height, 5);
            p.fill(30); p.textAlign(p.CENTER, p.CENTER);
            p.textSize(Math.min(key.width, key.height) * 0.45);
            p.text(key.label || key.key.toUpperCase(), key.x + key.width / 2, key.y + key.height / 2);
        }
    }
    function drawMenu() {
        p.fill(255); p.textAlign(p.CENTER);
        p.textSize(Math.min(36, width / 10)); p.text('CGモデリング', width / 2, height / 4 - 50); // Adjusted for spacing
        p.textSize(Math.min(32, width / 12)); p.text('タイピングゲーム NEO', width / 2, height / 4 -10); // Adjusted for spacing
        p.textSize(12); p.textAlign(p.RIGHT); p.fill(255, 255, 255, 150);
        p.text(GAME_VERSION, width - 10, height - 10);

        p.textSize(18);
        let modeText = wordMode === 'katakana' ? 'カタカナ' : (wordMode === 'hiragana' ? 'ひらがな' : 'ミックス');
        let diffText = difficulty === 'easy' ? 'かんたん' : (difficulty === 'normal' ? 'ふつう' : (difficulty === 'hard' ? 'むずかしい' : 'チュートリアル'));
        p.fill(255); p.textAlign(p.CENTER);
        p.text(`モード: ${modeText} / 難易度: ${diffText}`, width / 2, height / 4 + 30); // Adjusted for spacing
        for (const button of menuButtons) button.draw();
    }
    function drawSettings() {
        p.fill(255); p.textAlign(p.CENTER, p.TOP);
        p.textSize(Math.min(32, width/12)); p.text('設定', width / 2, height / 8);
        const drawSettingButtonWithSelection = (button, isSelected) => button.draw(isSelected);
        
        p.fill(255); p.textSize(20); p.textAlign(p.CENTER);
        if (modeSettingButtons.length > 0) p.text("表示モード", width/2, modeSettingButtons[0].y - 30); // Adjusted offset
        for (const button of modeSettingButtons) {
            drawSettingButtonWithSelection(button,
                (button.text.includes('カタカナ') && wordMode === 'katakana') ||
                (button.text.includes('ひらがな') && wordMode === 'hiragana') ||
                (button.text.includes('ミックス') && wordMode === 'mixed')
            );
        }
        if (difficultySettingButtons.length > 0) p.text("難易度", width/2, difficultySettingButtons[0].y - 30); // Adjusted offset
        for (const button of difficultySettingButtons) {
            drawSettingButtonWithSelection(button,
                (button.text === 'かんたん' && difficulty === 'easy') ||
                (button.text === 'ふつう' && difficulty === 'normal') ||
                (button.text === 'むずかしい' && difficulty === 'hard')
            );
        }
        for (const button of settingsScreenButtons) button.draw();
    }
    function drawPauseScreen() {
        p.fill(0, 0, 0, 150); p.rect(0, 0, width, height);
        p.fill(255); p.textAlign(p.CENTER); p.textSize(Math.min(32, width/10));
        p.text('一時停止中', width / 2, height / 3);
        for (const button of pauseMenuButtons) button.draw();
    }
    function calculatePerformanceMetrics() {
        const gameDurationPlayed = GAME_DURATIONS[difficulty] - (gameState === GAME_STATES.RESULTS ? 0 : timeLeft);
        const gameDurationMinutes = Math.max(1, gameDurationPlayed) / 60; 

        if (gameDurationMinutes <= 0) return { wpm: 0, cpm: 0, accuracy: 0 };
        const wpm = gameStats.correctCharsTyped > 0 ? Math.round((gameStats.correctCharsTyped / 5) / gameDurationMinutes) : 0;
        const cpm = gameStats.correctCharsTyped > 0 ? Math.round(gameStats.correctCharsTyped / gameDurationMinutes) : 0;
        const accuracy = gameStats.totalKeystrokes > 0 ? Math.round((gameStats.correctKeystrokes / gameStats.totalKeystrokes) * 100) : (gameStats.wordsTyped > 0 ? 100 : 0);
        return { wpm, cpm, accuracy };
    }
    function drawResultsScreen() {
        p.fill(0, 0, 0, 180); p.rect(0, 0, width, height);
        p.fill(255); p.textAlign(p.CENTER);
        p.textSize(Math.min(32, width/10)); p.text('結果発表', width / 2, height / 5);
        const metrics = calculatePerformanceMetrics();
        const isNewHighScore = (difficulty !== 'tutorial' && score > (highScores[difficulty] || 0));

        p.textSize(Math.min(24, width/15)); let yPos = height / 5 + 60;
        p.text('スコア: ' + score, width / 2, yPos); yPos += 40;
        p.textSize(Math.min(20, width/18));
        p.text('入力した単語数: ' + gameStats.wordsTyped, width / 2, yPos); yPos += 30;
        p.text('最大コンボ: ' + maxCombo, width / 2, yPos); yPos += 30;
        p.text('WPM (単語/分): ' + metrics.wpm, width / 2, yPos); yPos += 30;
        p.text('CPM (文字/分): ' + metrics.cpm, width / 2, yPos); yPos += 30;
        p.text('正確さ: ' + metrics.accuracy + '%', width / 2, yPos); yPos += 40;
        if (isNewHighScore && difficulty !== 'tutorial') {
            p.fill(255, 255, 0); p.textSize(Math.min(28, width/12));
            p.text('新記録達成!', width / 2, yPos);
        }
        const buttonWidth = Math.min(250, width - 60); const buttonHeight = Math.min(50, height/12);
        const resultsRetryButton = new Button(width/2 - buttonWidth/2, height * 0.75, buttonWidth, buttonHeight, 'もう一度プレイ', () => { p.loop(); retryGame(); });
        const resultsMenuButton = new Button(width/2 - buttonWidth/2, height * 0.75 + buttonHeight + 15, buttonWidth, buttonHeight, 'メニューに戻る', () => { p.loop(); returnToMenu(); });
        resultsRetryButton.draw(); resultsMenuButton.draw();
    }
    function drawHighScores() {
        p.fill(255); p.textAlign(p.CENTER);
        p.textSize(Math.min(32, width/10)); p.text('ハイスコア', width / 2, height / 4);
        p.textSize(Math.min(24, width/15));
        p.text('かんたん: ' + (highScores.easy || 0), width / 2, height / 4 + 70);
        p.text('ふつう: ' + (highScores.normal || 0), width / 2, height / 4 + 110);
        p.text('むずかしい: ' + (highScores.hard || 0), width / 2, height / 4 + 150);
        const buttonWidth = Math.min(200, width - 40); const buttonHeight = Math.min(50, height/12);
        const backButtonY = height / 4 + 150 + buttonHeight + 20; // Position relative to last text
        const backButton = new Button(width/2 - buttonWidth/2, backButtonY, buttonWidth, buttonHeight, 'もどる', () => { gameState = GAME_STATES.MENU; });
        backButton.draw();
    }
    function drawTutorialScreen() {
        // Call drawGameScreen elements for background consistency, but overlay tutorial content
        if (difficulty === 'tutorial') {
             // Simplified drawGameScreen content for tutorial background
            if (p.millis() - lastSpawnTime > SPAWN_INTERVALS[difficulty]) { /* ... word spawning ... */ }
            for (let i = words.length - 1; i >= 0; i--) { words[i].update(); words[i].draw(); if (!words[i].isActive) words.splice(i, 1); }
            for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); particles[i].draw(); if (particles[i].isDead()) particles.splice(i, 1); }
            drawGamePlayUI(); // Draw score, time, etc.
            drawInputArea();  // Draw input area
            if (isMobile) { // Keyboard logic for tutorial screen
                if (isFlickInputActive) {
                    drawFlickKeyboard();
                } else if (isVirtualKeyboardVisible) {
                    drawVirtualKeyboard();
                }
            }
        }
        p.fill(0,0,0,190); p.rect(0,0,width,height); // Tutorial overlay

        p.fill(255); p.textAlign(p.CENTER);
        p.textSize(Math.min(28, width/12)); p.text('チュートリアル', width / 2, height / 5); // Adjusted Y for title
        p.textSize(Math.min(18, width / 23));
        let tutorialText = [];
        let textBlockYStart = height / 5 + 70; // Start Y for the text block, give more space after title
        let lineHeight = 30; // Reduced line height for potentially more text

        if (tutorialStep === 0) {
            tutorialText = [
                'タイピングゲームNEOへようこそ！',
                '画面上から落ちてくる単語のローマ字を正確に入力します。',
                '例:「ポリゴン」→「porigon」。',
                '画面下のキーボードが光って補助します(PC)。',
                '（このチュートリアル中はカタカナ・かんたん設定です）'
            ];
        } else if (tutorialStep === 1) {
            tutorialText = [
                '正確な入力でスコア獲得。連続成功でコンボボーナス！',
                'タイプミスや単語を見逃すとコンボが途切れます。',
                '単語を完成させると効果音と共にエフェクトが発生します。',
                '制限時間内にハイスコアを目指しましょう！'
            ];
        } else if (tutorialStep === 2) {
             tutorialText = [
                '設定で難易度や表示モード(カタカナ/ひらがな/ミックス)を変更可能。',
                'サウンドのオン/オフも設定できます。(効果音ファイル要)',
                '準備ができたらメインメニューからスタート！健闘を祈ります！'
            ];
        } else { returnToMenu(); return; }

        for(let i=0; i < tutorialText.length; i++) p.text(tutorialText[i], width / 2, textBlockYStart + i * lineHeight);

        const buttonWidth = Math.min(200, width - 40); const buttonHeight = Math.min(50, height/12);
        const nextButtonY = textBlockYStart + tutorialText.length * lineHeight + 35; // Position below text block with a bit more padding
        const nextButtonText = tutorialStep < 2 ? '次へ' : 'メニューへ';
        const tutorialNextButton = new Button(width/2 - buttonWidth/2, nextButtonY, buttonWidth, buttonHeight, nextButtonText, () => {
            if (tutorialStep < 2) {
                tutorialStep++; if (difficulty === 'tutorial') { words = []; currentInput = ''; particles = []; }
            } else returnToMenu();
        });
        tutorialNextButton.draw();
    }

    function checkWordMatch() {
        let wordMatchedThisFrame = null;
        for (let i = words.length - 1; i >= 0; i--) {
            if (words[i].isFullyTypedBy(currentInput)) {
                wordMatchedThisFrame = words[i];
                score += wordMatchedThisFrame.romaji.length * 10 * (Math.max(1, combo));
                gameStats.correctCharsTyped += wordMatchedThisFrame.romaji.length;
                
                const particleCount = p.random(25, 40);
                const wordCenterX = wordMatchedThisFrame.x + p.textWidth(wordMatchedThisFrame.japanese) / 2;
                for (let j = 0; j < particleCount; j++) {
                    particles.push(new Particle(wordCenterX, wordMatchedThisFrame.y, p.color(p.random(200,255),p.random(150,255),50) ));
                }
                triggerScreenShake(12, 4); 
                playSound(sounds.word_complete || sounds.correct); 
                
                gameStats.wordsTyped++; combo++;
                if (combo > maxCombo) maxCombo = combo;
                if (combo > 0 && combo % 5 === 0) playSound(sounds.combo_increase);

                wordMatchedThisFrame.markCleared(); 
                if (difficulty === 'hard') timeLeft = Math.min(timeLeft + 1, GAME_DURATIONS.hard + 5);
                currentInput = '';
                break; 
            }
        }
        for (const word of words) word.updateStateFromInput(currentInput);
    }

    function checkAndSaveHighScore() {
        if (difficulty === 'tutorial') return false;
        let isNewRecord = false;
        if (score > (highScores[difficulty] || 0) ) {
            highScores[difficulty] = score; isNewRecord = true;
            try { localStorage.setItem('cgTypingHighScores_NEO', JSON.stringify(highScores)); }
            catch (e) { console.error("Error saving high scores:", e); }
        }
        return isNewRecord;
    }

    function handleTypingInput(key) {
        playSound(sounds.type);
        currentInput += key.toLowerCase();
        keyboardOverlay.keyStates[key.toLowerCase()] = keyboardOverlay.highlightDuration; 

        gameStats.totalKeystrokes++; gameStats.totalCharsTyped++;
        let isCorrectPrefixForAnyWord = false;
        for (const word of words) {
            if (!word.isCleared && word.romaji.startsWith(currentInput)) {
                isCorrectPrefixForAnyWord = true; break;
            }
        }

        if (isCorrectPrefixForAnyWord) gameStats.correctKeystrokes++;
        else {
            if (currentInput.length > 0) {
                if (combo > 0) playSound(sounds.combo_break); 
                combo = 0; playSound(sounds.wrong);
            }
        }
        checkWordMatch();
    }

    p.keyPressed = function() {
        if (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL) {
            if (p.keyCode === p.ESCAPE) { pauseGame(); return false; }
            if (!isMobile) {
                if (p.keyCode === p.BACKSPACE) {
                    currentInput = currentInput.slice(0, -1);
                    for (const word of words) word.updateStateFromInput(currentInput);
                } else if (p.key.length === 1 && p.key.match(/^[a-z0-9]$/i)) {
                    handleTypingInput(p.key);
                }
                return false;
            }
        } else if (gameState === GAME_STATES.PAUSED) {
            if (p.keyCode === p.ESCAPE) { resumeGame(); return false; }
        }
        return true;
    };

    p.mousePressed = function() {
        const mouseX = p.mouseX; const mouseY = p.mouseY;
        let buttonClickedSoundPlayed = false;

        const generalButtonClick = () => {
            if (!buttonClickedSoundPlayed) { playSound(sounds.click); buttonClickedSoundPlayed = true; }
        };

        // Priority handling for flick input if active
        if (isMobile && isFlickInputActive && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL)) {
            for (const keyObj of flickKeyboardLayout) {
                if (mouseX >= keyObj.x && mouseX <= keyObj.x + keyObj.w && mouseY >= keyObj.y && mouseY <= keyObj.y + keyObj.h) {
                    touchState.startX = mouseX;
                    touchState.startY = mouseY;
                    touchState.currentKey = keyObj;
                    touchState.isFlicking = true; // Tentatively start flicking
                    if (gameState === GAME_STATES.PAUSED || (gameState !== GAME_STATES.PLAYING && gameState !== GAME_STATES.TUTORIAL)) p.loop(); // Ensure draw updates for feedback if paused
                    return false; // Consume this press
                }
            }
        }

        if (gameState === GAME_STATES.MENU) {
            for (const button of menuButtons) if (button.isClicked(mouseX, mouseY)) { generalButtonClick(); button.action(); return false; }
        } else if (gameState === GAME_STATES.SETTINGS) {
            for (const button of modeSettingButtons) if (button.isClicked(mouseX, mouseY)) { generalButtonClick(); button.action(); return false; }
            for (const button of difficultySettingButtons) if (button.isClicked(mouseX, mouseY)) { generalButtonClick(); button.action(); return false; }
            for (const button of settingsScreenButtons) {
                if (button.isClicked(mouseX, mouseY)) {
                    generalButtonClick(); 
                    if (button instanceof ToggleButton) button.toggle(); else button.action();
                    return false;
                }
            }
        } else if (gameState === GAME_STATES.HIGHSCORES) {
            const buttonWidth = Math.min(200, width - 40); const buttonHeight = Math.min(50, height/12);
            const backButtonY = height / 4 + 150 + buttonHeight + 20; // from drawHighScores
            const backButtonRect = { x: width/2 - buttonWidth/2, y: backButtonY, w: buttonWidth, h: buttonHeight};
            if (mouseX >= backButtonRect.x && mouseX <= backButtonRect.x + backButtonRect.w && mouseY >= backButtonRect.y && mouseY <= backButtonRect.y + backButtonRect.h) {
                generalButtonClick(); gameState = GAME_STATES.MENU; return false;
            }
        } else if (gameState === GAME_STATES.TUTORIAL) {
            if (gameplayPauseButton && gameplayPauseButton.isClicked(mouseX, mouseY)) { generalButtonClick(); pauseGame(); return false; }

            // Check tutorial's own next button first if not currently flicking
            if (!touchState.isFlicking) {
                const buttonWidth = Math.min(200, width - 40); const buttonHeight = Math.min(50, height/12);
                const textBlockYStart = height / 5 + 70; const lineHeight = 30;
                let tutorialTextLength = 0;
                if (tutorialStep === 0) tutorialTextLength = 5;
                else if (tutorialStep === 1) tutorialTextLength = 4;
                else tutorialTextLength = 3;
                const nextButtonY = textBlockYStart + tutorialTextLength * lineHeight + 35;
                const nextButtonRect = {x: width/2 - buttonWidth/2, y: nextButtonY, w: buttonWidth, h: buttonHeight};

                if (mouseX >= nextButtonRect.x && mouseX <= nextButtonRect.x + nextButtonRect.w && mouseY >= nextButtonRect.y && mouseY <= nextButtonRect.y + nextButtonRect.h) {
                    generalButtonClick();
                    if (tutorialStep < 2) { tutorialStep++; if (difficulty === 'tutorial') { words = []; currentInput = ''; particles = [];}} else returnToMenu();
                    return false;
                }
            }
             // If not flicking on a key, or if flick is not active, allow other game touch (like input area)
            if (!isFlickInputActive || !touchState.currentKey) { // if flick is active, currentKey would be set if a flick key was pressed
                 if (handleMobileGameTouch(mouseX, mouseY) === false) return false;
            }

        } else if (gameState === GAME_STATES.PLAYING) {
            if (gameplayPauseButton && gameplayPauseButton.isClicked(mouseX, mouseY)) { generalButtonClick(); pauseGame(); return false; }
            if (!isFlickInputActive || !touchState.currentKey) {
                if (handleMobileGameTouch(mouseX, mouseY) === false) return false;
            }

        } else if (gameState === GAME_STATES.PAUSED) {
            for (const button of pauseMenuButtons) if (button.isClicked(mouseX, mouseY)) { generalButtonClick(); button.action(); return false; }
        } else if (gameState === GAME_STATES.RESULTS) {
            p.loop(); 
            const buttonWidth = Math.min(250, width - 60); const buttonHeight = Math.min(50, height/12);
            const playAgainButtonRect = {x: width/2 - buttonWidth/2, y: height * 0.75, w: buttonWidth, h: buttonHeight};
            const menuButtonRect = {x: width/2 - buttonWidth/2, y: height * 0.75 + buttonHeight + 15, w: buttonWidth, h: buttonHeight};
            if (mouseX >= playAgainButtonRect.x && mouseX <= playAgainButtonRect.x + playAgainButtonRect.w && mouseY >= playAgainButtonRect.y && mouseY <= playAgainButtonRect.y + playAgainButtonRect.h) {
                generalButtonClick(); retryGame(); return false;
            }
            if (mouseX >= menuButtonRect.x && mouseX <= menuButtonRect.x + menuButtonRect.w && mouseY >= menuButtonRect.y && mouseY <= menuButtonRect.y + menuButtonRect.h) {
                generalButtonClick(); returnToMenu(); return false;
            }
        }

        // If flicking was started, ensure it's handled by mouseReleased, not other UI elements.
        if (touchState.isFlicking && touchState.currentKey) return false;

        return true; // Default: pass click through
    };

    p.mouseDragged = function() {
        if (isMobile && isFlickInputActive && touchState.isFlicking && touchState.currentKey) {
            // Minimal visual update on drag, actual character selection on release
            if (gameState === GAME_STATES.PAUSED || (gameState !== GAME_STATES.PLAYING && gameState !== GAME_STATES.TUTORIAL)) p.loop();
            return false; // Consume drag event
        }
        return true;
    };

    p.mouseReleased = function() {
        if (isMobile && isFlickInputActive && touchState.isFlicking && touchState.currentKey) {
            const dx = p.mouseX - touchState.startX;
            const dy = p.mouseY - touchState.startY;
            const flickThreshold = 20; // Min distance to be considered a flick
            let selectedKana = touchState.currentKey.flicks.center; // Default to center (tap)

            if (Math.abs(dx) > flickThreshold || Math.abs(dy) > flickThreshold) { // It's a flick
                if (Math.abs(dx) > Math.abs(dy)) { // Horizontal flick
                    if (dx > 0 && touchState.currentKey.flicks.right) selectedKana = touchState.currentKey.flicks.right;
                    else if (dx < 0 && touchState.currentKey.flicks.left) selectedKana = touchState.currentKey.flicks.left;
                } else { // Vertical flick
                    if (dy < 0 && touchState.currentKey.flicks.up) selectedKana = touchState.currentKey.flicks.up; // p5.js Y is inverted from typical UI
                    else if (dy > 0 && touchState.currentKey.flicks.down) selectedKana = touchState.currentKey.flicks.down;
                }
            }

            // console.log("Selected Kana for " + touchState.currentKey.label + ": ", selectedKana, "Key ID:", touchState.currentKey.id);

            let romajiToInput = "";
            let directAction = false;

            if (touchState.currentKey.id === 'backspace' || selectedKana === 'backspace') { // Ensure consistency
                currentInput = currentInput.slice(0, -1);
                directAction = true;
            } else if (touchState.currentKey.id === 'clear' || selectedKana === 'clear') {
                currentInput = '';
                if (combo > 0) playSound(sounds.combo_break); combo = 0;
                directAction = true;
            } else if (touchState.currentKey.id === 'toggle_qwerty' || selectedKana === 'toggle_qwerty') {
                isFlickInputActive = false;
                isVirtualKeyboardVisible = true; // Show QWERTY
                directAction = true;
                playSound(sounds.click);
            } else if (selectedKana) {
                // For '゛゜' and '小' keys, the selectedKana is already the character like '゛', 'っ', 'ゃ'
                // These will be converted by convertKanaToRomaji to placeholders or specific romaji.
                romajiToInput = convertKanaToRomaji(selectedKana);
            }

            if (!directAction && romajiToInput) {
                currentInput += romajiToInput;
                playSound(sounds.type);
                gameStats.totalKeystrokes++; // Approximating one flick/tap as one keystroke
                gameStats.totalCharsTyped += romajiToInput.length;

                let isCorrectPrefixForAnyWord = false;
                for (const word of words) {
                    if (!word.isCleared && word.romaji.startsWith(currentInput)) {
                        isCorrectPrefixForAnyWord = true; break;
                    }
                }
                if (isCorrectPrefixForAnyWord) {
                    gameStats.correctKeystrokes += romajiToInput.length; // Count all chars in correct segment
                } else {
                    // Check if the input was incorrect *before* this romajiToInput was added.
                    // Only penalize (break combo, play_wrong_sound) if the currentInput *without* romajiToInput
                    // was a valid prefix for at least one word, or if it was empty.
                    const previousInput = currentInput.substring(0, currentInput.length - romajiToInput.length);
                    let wasPreviouslyCorrectOrEmpty = previousInput.length === 0;
                    if (previousInput.length > 0) {
                        for (const word of words) {
                            if (!word.isCleared && word.romaji.startsWith(previousInput)) {
                                wasPreviouslyCorrectOrEmpty = true;
                                break;
                            }
                        }
                    }

                    if (wasPreviouslyCorrectOrEmpty) {
                        if (combo > 0) playSound(sounds.combo_break);
                        combo = 0;
                        playSound(sounds.wrong);
                    }
                }
                checkWordMatch();
            }

            // Update all word states regardless of direct action or romaji input
            for (const word of words) word.updateStateFromInput(currentInput);

            touchState.isFlicking = false;
            touchState.currentKey = null;
            if (gameState === GAME_STATES.PAUSED || (gameState !== GAME_STATES.PLAYING && gameState !== GAME_STATES.TUTORIAL) ) p.noLoop();
            return false; // Consume release event
        }
        // Reset if flick was not completed or not active
        touchState.isFlicking = false;
        touchState.currentKey = null;
        return true;
    };

    function handleMobileGameTouch(touchX, touchY) {
        if (isMobile && (gameState === GAME_STATES.PLAYING || gameState === GAME_STATES.TUTORIAL)) {
            // Input area touch - only toggle QWERTY visibility if flick is NOT active
            const inputAreaHeight = 40;
            let inputAreaY;
            if (isFlickInputActive) { // Flick keyboard is typically taller
                 inputAreaY = height - (Math.min(height / 9, 80) * 4 + (Math.min(width / 5, 80) * 0.15 * 3)) - inputAreaHeight - 20; // Approx flick keyboard height
            } else if (isVirtualKeyboardVisible) { // QWERTY visible
                 inputAreaY = height - (Math.min(width / 11, 45) + Math.max(2, (Math.min(width / 11, 45)) * 0.05)) * 4.5 - inputAreaHeight - 10;
            } else { // No keyboard visible
                 inputAreaY = height - inputAreaHeight - 20;
            }
            const inputAreaRect = { x: width / 2 - 150, y: inputAreaY, w: 300, h: inputAreaHeight };

            if (touchX >= inputAreaRect.x && touchX <= inputAreaRect.x + inputAreaRect.w && touchY >= inputAreaRect.y && touchY <= inputAreaRect.y + inputAreaRect.h) {
                if (!isFlickInputActive) { // Only toggle QWERTY if flick is not active
                    isVirtualKeyboardVisible = !isVirtualKeyboardVisible;
                }
                playSound(sounds.click); return false;
            }

            if (isFlickInputActive) {
                // Flick keyboard touch handling (initial structure)
                // This will be handled by p.mousePressed, p.mouseDragged, p.mouseReleased sections for flick
            } else if (isVirtualKeyboardVisible) { // QWERTY keyboard touch
                for (const key of virtualKeyboard) {
                    if (touchX >= key.x && touchX <= key.x + key.width && touchY >= key.y && touchY <= key.y + key.height) {
                        if (key.key === 'backspace') {
                            currentInput = currentInput.slice(0, -1);
                            for (const word of words) { word.updateStateFromInput(currentInput); }
                        } else if (key.key === 'clear') {
                            currentInput = ''; if (combo > 0) playSound(sounds.combo_break); combo = 0;
                            for (const word of words) { word.updateStateFromInput(currentInput); }
                        } else if (key.key === 'toggle_flick') {
                            isFlickInputActive = true;
                            isVirtualKeyboardVisible = false;
                            if (flickKeyboardLayout.length === 0) createFlickKeyboard();
                            playSound(sounds.click);
                        } else {
                            handleTypingInput(key.key); 
                        }
                        return false; // Handled QWERTY key press
                    }
                }
            }
        }
        return true; // Allow click to pass through if not handled by UI elements above
    }

    function playBackgroundMusic() {
        if (!sounds.bgm || !soundEnabled || bgmPlaying) return;
        sounds.bgm.play().then(() => { bgmPlaying = true; })
                         .catch(e => { console.error("BGM play error:", e); bgmPlaying = false; });
    }

    p.windowResized = function() {
        width = p.windowWidth; height = p.windowHeight;
        p.resizeCanvas(width, height); createButtons();
        if (isMobile) {
            createVirtualKeyboard();
            if (flickKeyboardLayout.length > 0 || isFlickInputActive) createFlickKeyboard(); // Recreate if it was active or already created
        }
        initKeyboardOverlay(); 
    };
};
new p5(sketch);
    </script>
<footer class="text-center mt-12 py-8 border-t border-stone-300">
  <p class="text-sm text-stone-600">&copy; 2025 TK2 LAB.</p>
</footer>

</body>
</html>
